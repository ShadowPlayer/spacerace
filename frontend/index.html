<!doctype html>
<html>
<head>
    <title>Spacerace</title>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font: 13px Helvetica, Arial;
        }

        path.mapBorder {
            stroke: steelblue;
            stroke-width: 10px;
            fill: none;
        }
        path.startLine {
            stroke: black;
            stroke-width: 2px;
            stroke-dasharray: 5px;
            fill: none;
        }
        path.finishLine {
            stroke: red;
            stroke-width: 2px;
            stroke-dasharray: 5px;
            fill: none;
        }

        polygon.startZone {
            opacity: 0.2;
            stroke: black;
            stroke-width: 5px;
            fill: none;
        }

        polygon.shipWings {
            opacity: 0.8;
        }

        polygon.shipStripe {
            fill: black;
        }

        circle.shipBody {
            stroke-width: 1px;
        }

        line.shipJet {
            stroke-width: 10px;
            stroke: black;
        }

        use {
            will-change: transform;
        }


    </style>

</head>
<body>
<svg id="game"></svg>
<div id="fps">FPS: <span>?</span></div>
<div id="leaderboard"></div>

<script src="socket.io/socket.io.js"></script>
<script src="d3/d3.min.js"></script>

<script>
    var socket = io();
    var requestID;
    var gameState;
    var lastUpdateTime;

    var updates = 0;
    var draws = 0;
    var fpsqueue = [];

    socket.on('GameState', function (msg) {
        gameState = JSON.parse(msg).data;

        if(msg.status === "IN GAME") {
            updates += 1;

            if (updates == 1) {
                setupGame()
            }
        }

        if(msg.status === "GAME OVER"){
            console.log("Game Over");
        }
    });

    //socket.on('GameMap', function (msg) {
    //    var data = JSON.parse(msg).data;
    //    setupGame(data)
    //}


</script>
<script>
    var width = 720,
        height = 720;

    var svgContainer = d3.select('#game')
            .attr("width", width)
            .attr("height", height);


    var fps = d3.select("#fps span");

    // Assume positions are between 0 and 100 for now
    // (0,0) is at the bottom left
    var x = d3.scale.linear().domain([0, 100]).range([0, width]);
    var y = d3.scale.linear().domain([0, 100]).range([height, 0]);

    var shipG = svgContainer.append("defs")
            .append("symbol")
            .attr("viewBox", "0 0 50 50")
            .attr("id", "ship")
            .attr("class", "ship");


    shipG.append("polygon")
        .attr("points", "25,2 47,37 3,37")
        .attr("class", "shipWings");


    // For now the jet "backwards" is simply a solid red line
    shipG.append("line")
            .attr("class", "shipJet")
            .attr("x1", 25)
            .attr("y1", 35)
            .attr("x2", 25)
            .attr("y2", 45);

    // Main circular body of the ship
    shipG.append("circle")
            .attr("class", "shipBody")
            .attr('cx', 25)
            .attr('cy', 25)
            .attr('r', function (d, i) { return 16; });


    shipG.append("polygon")
            .attr("points", "23,30 27,30 25,5")
            .attr("class", "shipStripe");



    var shipGroup = svgContainer.append("g").attr("id", "shipsParentGroup");
    var map = svgContainer.append("g");
    var ships;

    var splineFunction = d3.svg.line()
        .x(function(d) { return x(d.x); })
        .y(function(d) { return y(d.y); })
        .interpolate("basis");

    var lineFunction = d3.svg.line()
        .x(function(d) { return x(d.x); })
        .y(function(d) { return y(d.y); })
        .interpolate("linear");


    /**
     * Still have to work out how we will do maps...
     * But for now lets draw two splines
     */
    var startZone = [
        {"x": 5,   "y": 5},
        {"x": 5,   "y": 25},
        {"x": 25.0,"y": 25},
        {"x": 25.0,"y": 5}];

    var startLineData = [
        { "x": 25,   "y": 5},
        { "x": 25,   "y": 25}
    ];
    var finishLineData = [
        { "x": 90,   "y": 80},
        { "x": 80,   "y": 80}
    ];

    var lineDataTop = [
        { "x": 25,   "y": 5},
        { "x": 27,   "y": 5},
        { "x": 28,  "y": 20},
        { "x": 40,  "y": 10},
        { "x": 60,  "y": 40},
        { "x": 80,  "y": 5},
        { "x": 90, "y": 60},
        { "x": 90, "y": 80}
    ];
    var lineDataBottom = [
        { "x": 25,   "y": 20 + 5},
        { "x": 25,   "y": 20 + 5},
        { "x": Math.random(10) + 25,  "y": 20 + 20},
        { "x": Math.random(10) + 40,  "y": 20 + 10},
        { "x": Math.random(10) + 60,  "y": 20 + 40},
        { "x": Math.random(10) + 80,  "y": 20 + 5},
        { "x": 80, "y": 20 + 60}
    ];

    var setupGame = function() {
        var initState = gameState;
        var SHIPSIZE = "10";

        ships = shipGroup
            .selectAll('.ship')
            .data(initState)
            .enter()
            .append('use')
            .attr("transform", function(d, i){return "translate(0, 0)";})
            .attr("id", function(d, i){return "ship"+i;})
            .attr("xlink:href", "#ship")
            .attr("width", SHIPSIZE)
            .attr("height", SHIPSIZE)
            .attr('fill', function () {
                return "hsl(" + Math.random() * 360 + ",75%, 50%)"
            });

        map.append("path")
            .attr("class", "mapBorder")
            .attr("d", splineFunction(lineDataTop));

        map.append("path")
            .attr("class", "mapBorder")
            .attr("d", splineFunction(lineDataBottom));

        map.append("path")
            .attr("class", "startLine")
            .attr("d", lineFunction(startLineData));

        map.append("path")
            .attr("class", "finishLine")
            .attr("d", lineFunction(finishLineData));

        map.selectAll("polygon")
            .data([startZone])
            .enter().append("polygon")
            .attr("class", "startZone")
            .attr("points",function(d) {
                return d.map(function(d){return [x(d.x),y(d.y)].join(","); }).join(" ");})
            .attr("stroke","black")
            .attr("stroke-width",2);


        // Trigger the first full draw
        updateState();

    };

    var updateState = function (highResTimestamp){


        requestID = requestAnimationFrame(updateState);



        if(updates >= draws) {
            // Only update the ships if we have gotten an update from the server
            draws += 1;

            // Calculate an fps counter
            if (fpsqueue.length >= 100) { fps.text(d3.mean(fpsqueue).toFixed(0)); fpsqueue = fpsqueue.slice(1, 100); }
            fpsqueue.push(Math.round(1000 / (highResTimestamp - lastUpdateTime)));
            lastUpdateTime = highResTimestamp;


            ships
                .data(gameState)
                .attr('opacity', function (d, i) {
                    // Show accelerating with opacity toggle
                    var accelerating = d.Tl == 1;
                    return accelerating ? 1.0 : 0.2;
                })
                .attr("x", function (d, i) {return x(d.x);})
                .attr("y", function (d, i) {return y(d.y);})
                .attr("transform", function (d, i) {
                    // It is possible to both update ships' position and rotation using a single SVG transform/rotation
                    // command however it doesn't seem as performant as using the x,y attributes as above.

                    var shipX = x(d.x),
                        shipY = y(d.y);

                    //return "translate(" + shipX + ", " + shipY + ") + ...
                    // Note SVG rotate takes degrees not radians, and it also takes X, Y to rotate around
                    return "rotate(" +
                            (90 - d.theta * 360/(2*Math.PI)) +
                            "," + shipX + ", " + shipY +
                            ")";
                });

        }


    }

</script>
</body>
</html>